<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用 IDEA 构建 Spring5.3.10 源码</title>
      <link href="/posts/983a1c52.html"/>
      <url>/posts/983a1c52.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>此教程是基于周瑜老师的 <strong>Spring5.3.10 注释版源码</strong>编译的，并不是 Github 原生的 Spring5.3.10 源码，有一些差别，但都是 gradle 配置文件的微小改动，比如把某些依赖从 optional 改成 compile 级别、修改了 gradle 仓库的地址（主要是为了方便编译），其他都没改动。</p></blockquote><h1 id="一、版本"><a href="#一、版本" class="headerlink" title="一、版本"></a>一、版本</h1><ul><li>Spring 版本：5.3.10</li><li>Gradle 版本：6.8</li><li>IDEA 版本：2022.2</li></ul><p><img src="/posts/983a1c52/1685515451815-c83a27f4-385a-42d9-8156-a24808c36be0.png" alt="IDEA 版本"></p><h1 id="二、下载Spring源码所需要的依赖"><a href="#二、下载Spring源码所需要的依赖" class="headerlink" title="二、下载Spring源码所需要的依赖"></a>二、下载Spring源码所需要的依赖</h1><p>因为Spring源码存在很多依赖包，如果自行下载，会需要下很久，所以此处将我自己电脑上已下载的依赖给出：</p><blockquote><p>链接：<a href="https://caiyun.139.com/m/i?005CiN4dFp6mN">https://caiyun.139.com/m/i?005CiN4dFp6mN</a></p><p>提取码：TbOy</p></blockquote><h1 id="三、下载-Spring-源码"><a href="#三、下载-Spring-源码" class="headerlink" title="三、下载 Spring 源码"></a>三、下载 Spring 源码</h1><p>git clone 的地址为：<a href="https://gitee.com/dhpro/spring-framework-5.3.10.git">https://gitee.com/dhpro/spring-framework-5.3.10.git</a></p><p>建议直接用 IDEA 的 git 来下载源码：</p><p><img src="/posts/983a1c52/1685515617531-5c3d6c65-6af1-42be-8572-11f4717c6fa4.png" alt="New Project"></p><p><img src="/posts/983a1c52/1685515622726-73454c6c-2a1f-448b-8e14-6080485a8a56.png" alt="Clone"></p><p>输入地址，点击 Clone，就会开始下载源码工程（因为是从 gitee 上下载，所以会比从 github 上下载快很多)。 一旦下载完成，IDEA 就会自动下载 gradle，下载完 gradle 就会开始下载 Spring 源码依赖，但是我们已经有现成的了，所以可以直接取消这个过程。</p><h1 id="四、修改IDEA的gradle配置"><a href="#四、修改IDEA的gradle配置" class="headerlink" title="四、修改IDEA的gradle配置"></a>四、修改IDEA的gradle配置</h1><p><img src="/posts/983a1c52/1685515713115-b417e4cf-fa0e-4376-b06b-b524e144cbe9.png" alt="Gradle 配置"></p><p>首先把 gradle user home 改为 <strong>.gradle压缩包</strong> 的解压之后的文件路径，</p><p>然后把 Build and run using 和 Run tests using 都改为 IntelliJ IDEA，</p><p>改完之后点击 Apply，再点击 OK，会自动触发 gradle 的重新编译。</p><h1 id="五、运行代码"><a href="#五、运行代码" class="headerlink" title="五、运行代码"></a>五、运行代码</h1><p>编译成功后，在左侧可以看到如下模块，其中有一个 tuling 模块，这是一个可以直接运行的模块，在它下面有一个 Test 类，直接运行 main 方法。</p><p><img src="/posts/983a1c52/1685515818638-aa54c79e-7e57-4441-9757-ea00a0bf6274.png" alt="Test"></p><h2 id="5-1-运行过程中可能出现的问题"><a href="#5-1-运行过程中可能出现的问题" class="headerlink" title="5.1 运行过程中可能出现的问题"></a>5.1 运行过程中可能出现的问题</h2><h3 id="5-1-1-问题一"><a href="#5-1-1-问题一" class="headerlink" title="5.1.1 问题一"></a>5.1.1 问题一</h3><p>我在运行的时候出现了以下错误：</p><p><img src="/posts/983a1c52/1685515894900-3d9a036b-beaf-4505-a394-039d87d10d82.png" alt="报错 1"></p><p>由于报错的是 core 模块，所以在 gradle 中找到 core 模块，先执行 clean，然后 build，执行完毕后重新运行程序，问题解决。</p><p><img src="/posts/983a1c52/1685515903538-7acd0039-35d6-48d3-8535-bd3659e3bbc8.png" alt="Clean"></p><p><img src="/posts/983a1c52/1685515909414-1dbb5934-710e-4d30-bc59-a1e4b47d51ce.png" alt="运行成功截图"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 框架 </category>
          
          <category> Spring </category>
          
          <category> Spring-5.3.10 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas</title>
      <link href="/posts/e1a71cf6.html"/>
      <url>/posts/e1a71cf6.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="1-1-什么是-Arthas"><a href="#1-1-什么是-Arthas" class="headerlink" title="1.1 什么是 Arthas"></a>1.1 什么是 Arthas</h2><p>Arthas 是一款线上监控诊断产品，通过全局视角实时查看应用 load、内存、gc、线程的状态信息，并能在不修改应用代码的情况下，对业务问题进行诊断，包括查看方法调用的出入参、异常，监测方法执行耗时，类加载信息等，大大提升线上问题排查效率。</p><h2 id="1-2-下载-Arthas"><a href="#1-2-下载-Arthas" class="headerlink" title="1.2 下载 Arthas"></a>1.2 下载 Arthas</h2><p>下载地址：<a href="https://arthas.aliyun.com/download/latest_version?mirror=aliyun">https://arthas.aliyun.com/download/latest_version?mirror=aliyun</a></p><h2 id="1-3-启动方式"><a href="#1-3-启动方式" class="headerlink" title="1.3 启动方式"></a>1.3 启动方式</h2><p>将下载的文件解压后，可以看到有 <code>as.sh</code>和 <code>arthas-boot.jar</code>，有两种启动方式</p><ul><li>直接执行 <code>./as.sh</code>启动</li><li>执行 <code>java -jar arthas-boot.jar</code>启动</li></ul><blockquote><p>需要注意的是：使用和目标进程一致的用户启动，否则可能 attach 失败</p><ul><li>执行该程序的用户需要和目标进程具有相同的权限。比如以 <code>admin</code>用户来执行：<code>sudo su admin &amp;&amp; java -jar arthas-boot.jar</code>或 <code>sudo -u admin -EH java -jar arthas-boot.jar</code>。</li><li>如果 attach 不上目标进程，可以查看<code>~/logs/arthas/</code>目录下的日志。</li></ul></blockquote><p>执行成功后会显示 Java 进程信息，输入对应的数字序号后回车，Arthas 会 attach 到目标进程上，并输出日志。</p><h5 id><a href="#" class="headerlink" title></a><img src="/posts/e1a71cf6/1685446464667-5b9471f9-ff69-4e3e-a665-9235f11676cb.png" alt="启动截图"></h5><h1 id="二、命令列表及其使用"><a href="#二、命令列表及其使用" class="headerlink" title="二、命令列表及其使用"></a>二、命令列表及其使用</h1><h2 id="2-1-JVM-相关"><a href="#2-1-JVM-相关" class="headerlink" title="2.1 JVM 相关"></a>2.1 JVM 相关</h2><h3 id="2-1-1-dashboard-当前系统的实时数据面板"><a href="#2-1-1-dashboard-当前系统的实时数据面板" class="headerlink" title="2.1.1 dashboard - 当前系统的实时数据面板"></a>2.1.1 dashboard - 当前系统的实时数据面板</h3><h4 id="2-1-1-1-作用"><a href="#2-1-1-1-作用" class="headerlink" title="2.1.1.1 作用"></a>2.1.1.1 作用</h4><p>显示当前系统的实时数据面板，按 <code>ctrl+c</code>退出。</p><h4 id="2-1-1-2-参数说明"><a href="#2-1-1-2-参数说明" class="headerlink" title="2.1.1.2 参数说明"></a>2.1.1.2 参数说明</h4><table><thead><tr><th align="center"><strong>参数名称</strong></th><th align="center"><strong>参数说明</strong></th></tr></thead><tbody><tr><td align="center">[i:]</td><td align="center">刷新实时数据的时间间隔 (ms)，默认 5000ms</td></tr><tr><td align="center">[n:]</td><td align="center">刷新实时数据的次数</td></tr></tbody></table><p>实例：<code>dashboard -i 1000 -n 2</code> ：每1000ms刷新一次，刷新两次。</p><h4 id="2-1-1-3-数据说明"><a href="#2-1-1-3-数据说明" class="headerlink" title="2.1.1.3 数据说明"></a>2.1.1.3 数据说明</h4><p><img src="/posts/e1a71cf6/1685498254758-2eb0afda-67ca-4d45-9a87-c3c08b555c70.png" alt="dashboard运行截图"></p><ul><li>ID: Java 级别的线程 ID，注意这个 ID 不能跟 jstack 中的 nativeID 一一对应。</li><li>NAME: 线程名</li><li>GROUP: 线程组名</li><li>PRIORITY: 线程优先级, 1~10 之间的数字，越大表示优先级越高</li><li>STATE: 线程的状态</li><li>CPU%: 线程的 cpu 使用率。比如采样间隔 1000ms，某个线程的增量 cpu 时间为 100ms，则 cpu 使用率&#x3D;100&#x2F;1000&#x3D;10%</li><li>DELTA_TIME: 上次采样之后线程运行增量 CPU 时间，数据格式为秒</li><li>TIME: 线程运行总 CPU 时间，数据格式为分:秒</li><li>INTERRUPTED: 线程当前的中断位状态</li><li>DAEMON: 是否是 daemon 线程</li></ul><p>从上图中可以看到有些线程的 ID、PRIORITY 为-1，且没有状态等属性，这是因为这些线程是 JVM 内部线程。</p><h4 id="2-1-1-4-JVM-内部线程"><a href="#2-1-1-4-JVM-内部线程" class="headerlink" title="2.1.1.4 JVM 内部线程"></a>2.1.1.4 JVM 内部线程</h4><p>Java 8 之后支持获取 JVM 内部线程 CPU 时间，这些线程只有名称和 CPU 时间，没有 ID 及状态等信息（显示 ID 为-1）。 通过内部线程可以观测到 JVM 活动，如 GC、JIT 编译等占用 CPU 情况，方便了解 JVM 整体运行状况。</p><ul><li>当 JVM 堆(heap)&#x2F;元数据(metaspace)空间不足或 OOM 时，可以看到 GC 线程的 CPU 占用率明显高于其他的线程。</li><li>当执行 <code>trace/watch/tt/redefine</code>等命令后，可以看到 JIT 线程活动变得更频繁。因为 JVM 热更新 class 字节码时清除了此 class 相关的 JIT 编译结果，需要重新编译。</li></ul><p>JVM 内部线程包括下面几种：</p><ul><li>JIT 编译线程: 如 <code>C2 CompilerThread0</code>, <code>C1 CompilerThread2</code></li><li>GC 线程: 如 <code>GC Thread0</code>, <code>G1 Young RemSet Sampling</code></li><li>其它内部线程: 如 <code>VM Periodic Task Thread</code>, <code>VM Thread</code>, <code>Service Thread</code></li></ul><h3 id="2-1-2-ognl-执行-ognl-表达式"><a href="#2-1-2-ognl-执行-ognl-表达式" class="headerlink" title="2.1.2 ognl - 执行 ognl 表达式"></a>2.1.2 ognl - 执行 ognl 表达式</h3><h4 id="2-1-2-1-作用"><a href="#2-1-2-1-作用" class="headerlink" title="2.1.2.1 作用"></a>2.1.2.1 作用</h4><p>执行 ognl 表达式</p><h4 id="2-1-2-2-参数说明"><a href="#2-1-2-2-参数说明" class="headerlink" title="2.1.2.2 参数说明"></a>2.1.2.2 参数说明</h4><table><thead><tr><th align="center"><strong>参数名称</strong></th><th align="center"><strong>参数说明</strong></th></tr></thead><tbody><tr><td align="center"><em>express</em></td><td align="center">执行的表达式</td></tr><tr><td align="center">[c:]</td><td align="center">执行表达式的 ClassLoader 的 hashcode，默认值是 SystemClassLoader</td></tr><tr><td align="center">[classLoaderClass:]</td><td align="center">指定执行表达式的 ClassLoader 的 class name</td></tr><tr><td align="center">[x]</td><td align="center">结果对象的展开层次，默认值 1</td></tr></tbody></table><h4 id="2-1-2-3-ognl-表达式说明"><a href="#2-1-2-3-ognl-表达式说明" class="headerlink" title="2.1.2.3 ognl 表达式说明"></a>2.1.2.3 ognl 表达式说明</h4><h5 id="2-1-2-3-1-语法"><a href="#2-1-2-3-1-语法" class="headerlink" title="2.1.2.3.1 语法"></a>2.1.2.3.1 语法</h5><p>基本的 OGNL 表达式非常简单。该语言的特性已经变得非常丰富，但是您通常不需要担心该语言中更复杂的部分：简单的情况仍然如此。例如，要获取对象的 name 属性，OGNL 表达式就是 <code>name</code>。要获取由 headline 属性返回的对象的 text 属性，OGNL 表达式是 <code>headline.text</code>。</p><p>OGNL 表达式的基本单元是导航链，通常简称为“链”。最简单的链条由以下部分组成：</p><table><thead><tr><th align="center"><strong>表达式元素部分</strong></th><th align="center"><strong>例子</strong></th></tr></thead><tbody><tr><td align="center">属性名称</td><td align="center">比如上面示例中的 <code>name</code>和 <code>headline.text</code>。</td></tr><tr><td align="center">方法调用</td><td align="center"><code>hashCode()</code>返回当前对象的哈希码</td></tr><tr><td align="center">数组索引</td><td align="center"><code>listeners[0]</code>返回当前对象 listeners 列表中的第一个</td></tr></tbody></table><p>所有 OGNL 表达式都在当前对象的上下文中求值，而链只是使用链中前一个链接的结果作为下一个链接的当前对象。你想把链条拉长多长都行。例如，这条链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name.toCharArray()[0].numericValue.toString()</span><br></pre></td></tr></table></figure><p>这个表达式按照以下步骤进行计算：</p><ol><li>提取初始或根对象（用户通过 OGNL 上下文提供给 OGNL ）的 name 属性；</li><li>在结果字符串上调用 toCharArray() 方法；</li><li>从结果数组中提取第一个字符（索引为0的字符）；</li><li>从该字符获取 numericValue 属性(字符表示为 <code>Character</code>对象，<code>Character</code>类有一个名为 getNumericValue() 的方法)。</li><li>在结果 Integer 对象上调用 toString()。这个表达式的最终结果是最后一次 toString() 调用返回的 String。</li></ol><p>请注意，这个示例只能用于从对象获取值，而不能用于设置值。将上述表达式传递给 Ognl.setValue() 方法将导致InappropriateExpressionException被抛出，因为链中的最后一个链接既不是属性名也不是数组索引。</p><h5 id="2-1-2-3-2-表达式"><a href="#2-1-2-3-2-表达式" class="headerlink" title="2.1.2.3.2 表达式"></a>2.1.2.3.2 表达式</h5><p>本节概述了 OGNL 表达式元素的细节。</p><p><strong>常量</strong></p><p>OGNL 有以下几种常量：</p><ul><li>String 字面值，如 Java 中由单引号或双引号分隔，并带有完整的转义集；</li><li>Character 字面量，也与 Java 一样：由单引号分隔，也带有全套转义；</li><li>数字字面值，比 Java 多一些类型。除了 Java 的整型、长型、浮点数和双精度外，OGNL 还允许您指定带有“b”或“b”后缀的 BigDecimals，以及带有“h”或“h”后缀的 BigIntegers(想想“huge”——我们选择了“h”表示)；</li><li>Boolean：true 或者 false；</li><li>null</li></ul><p><strong>引用属性</strong></p><p>OGNL 在处理属性引用时以不同的方式对待不同类型的对象。映射将所有属性引用视为元素查找或存储，并将属性名称作为键。列表和数组类似地处理数字属性，以属性名作为索引，但处理字符串属性的方式与普通对象相同。普通对象（即所有其他类型的对象）只能通过使用“get”和“set”方法（或“is”和“set”）处理字符串属性，如果对象有这些方法，或者使用给定名称的字段处理字符串属性。</p><p>注意这里的新术语。属性“名称”可以是任何类型，而不仅仅是字符串。但是要引用非字符串属性，必须使用我们一直称为“索引”的符号。例如，要获取一个数组的长度，你可以使用这个表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.length</span><br></pre></td></tr></table></figure><p>但是要获取数组的元素0，你必须使用这样的表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array[0]</span><br></pre></td></tr></table></figure><p><strong>索引</strong></p><p>如上所述，“索引”表示法实际上只是属性引用，尽管是一种计算形式的属性引用，而不是常数形式。<br>例如，OGNL在内部处理 <code>array.length</code>表达式与这个表达式完全相同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array[&quot;length&quot;]</span><br></pre></td></tr></table></figure><p>这个表达式会有相同的结果（尽管内部形式不同）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array[&quot;len&quot; + &quot;gth&quot;]</span><br></pre></td></tr></table></figure><h3 id="2-1-3-getstatic-查看类的静态属性"><a href="#2-1-3-getstatic-查看类的静态属性" class="headerlink" title="2.1.3 getstatic - 查看类的静态属性"></a>2.1.3 getstatic - 查看类的静态属性</h3><h3 id="2-1-4-heapdump-dump-java-heap-类似-jmap-命令的-heap-dump-功能"><a href="#2-1-4-heapdump-dump-java-heap-类似-jmap-命令的-heap-dump-功能" class="headerlink" title="2.1.4 heapdump - dump java heap, 类似 jmap 命令的 heap dump 功能"></a>2.1.4 heapdump - dump java heap, 类似 jmap 命令的 heap dump 功能</h3><h3 id="2-1-5-jvm-查看当前-JVM-的信息"><a href="#2-1-5-jvm-查看当前-JVM-的信息" class="headerlink" title="2.1.5 jvm - 查看当前 JVM 的信息"></a>2.1.5 jvm - 查看当前 JVM 的信息</h3><h3 id="2-1-6-logger-查看和修改-logger"><a href="#2-1-6-logger-查看和修改-logger" class="headerlink" title="2.1.6 logger - 查看和修改 logger"></a>2.1.6 logger - 查看和修改 logger</h3><h3 id="2-1-7-mbean-查看-Mbean-的信息"><a href="#2-1-7-mbean-查看-Mbean-的信息" class="headerlink" title="2.1.7 mbean - 查看 Mbean 的信息"></a>2.1.7 mbean - 查看 Mbean 的信息</h3><h3 id="2-1-8-memory-查看-JVM-的内存信息"><a href="#2-1-8-memory-查看-JVM-的内存信息" class="headerlink" title="2.1.8 memory - 查看 JVM 的内存信息"></a>2.1.8 memory - 查看 JVM 的内存信息</h3><h3 id="2-1-9-perfcounter-查看当前-JVM-的-Perf-Counter-信息"><a href="#2-1-9-perfcounter-查看当前-JVM-的-Perf-Counter-信息" class="headerlink" title="2.1.9 perfcounter - 查看当前 JVM 的 Perf Counter 信息"></a>2.1.9 perfcounter - 查看当前 JVM 的 Perf Counter 信息</h3><h3 id="2-1-10-sysenv-查看-JVM-的环境变量"><a href="#2-1-10-sysenv-查看-JVM-的环境变量" class="headerlink" title="2.1.10 sysenv - 查看 JVM 的环境变量"></a>2.1.10 sysenv - 查看 JVM 的环境变量</h3><h3 id="2-1-11-sysprop-查看和修改-JVM-的系统属性"><a href="#2-1-11-sysprop-查看和修改-JVM-的系统属性" class="headerlink" title="2.1.11 sysprop - 查看和修改 JVM 的系统属性"></a>2.1.11 sysprop - 查看和修改 JVM 的系统属性</h3><h3 id="2-1-12-thread-查看当前-JVM-的线程堆栈信息"><a href="#2-1-12-thread-查看当前-JVM-的线程堆栈信息" class="headerlink" title="2.1.12 thread - 查看当前 JVM 的线程堆栈信息"></a>2.1.12 thread - 查看当前 JVM 的线程堆栈信息</h3><h3 id="2-1-13-vmoption-查看和修改-JVM-里诊断相关的-option"><a href="#2-1-13-vmoption-查看和修改-JVM-里诊断相关的-option" class="headerlink" title="2.1.13 vmoption - 查看和修改 JVM 里诊断相关的 option"></a>2.1.13 vmoption - 查看和修改 JVM 里诊断相关的 option</h3><h3 id="2-1-14-vmtool-从-jvm-里查询对象"><a href="#2-1-14-vmtool-从-jvm-里查询对象" class="headerlink" title="2.1.14 vmtool - 从 jvm 里查询对象"></a>2.1.14 vmtool - 从 jvm 里查询对象</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 调试工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arthas </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
