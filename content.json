{"meta":{"title":"@DH Blog","subtitle":"","description":"","author":"Ding Huang","url":"https://itdh.github.io","root":"/"},"pages":[{"title":"文章分类","date":"2023-06-01T08:03:47.000Z","updated":"2023-06-01T08:15:20.923Z","comments":false,"path":"categories/index.html","permalink":"https://itdh.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2023-06-01T08:03:47.000Z","updated":"2023-06-02T03:34:47.490Z","comments":false,"path":"tags/index.html","permalink":"https://itdh.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SpringCloudAlibaba入门","slug":"SpringCloudAlibaba入门","date":"2023-08-05T03:31:27.000Z","updated":"2024-02-26T03:05:34.754Z","comments":true,"path":"posts/4c20f373.html","link":"","permalink":"https://itdh.github.io/posts/4c20f373.html","excerpt":"","text":"一、使用IDEA搭建一个分布式的项目1.1 创建基于SpringBoot的父工程 创建完成之后修改 pom.xml 文件，加上 &lt;packaging&gt;pom&lt;/packaging&gt; 父工程的 src 目录我们也不需要用到，所以可以删除 1.2 创建两个子模块（订单模块和库存模块）1.2.1 创建子模块 1.2.2 添加依赖在 order 和 stock 两个子模块的 pom.xml 文件中添加如下依赖： 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 1.3 在 order 模块中使用 RestTemplate 调用 stock 模块1.3.1 添加SpringBoot启动类1.3.1.1 order 模块123456789101112@SpringBootApplicationpublic class OrderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderApplication.class, args); &#125; @Bean public RestTemplate restTemplate(RestTemplateBuilder builder) &#123; return builder.build(); &#125;&#125; 1.3.1.2 stock 模块123456@SpringBootApplicationpublic class StockApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(StockApplication.class, args); &#125;&#125; 1.3.2 添加配置文件在 resources 目录下添加 application.yml 文件 1.3.2.1 order 模块12server: port: 8010 1.3.2.2 stock模块12server: port: 8011 1.3.3 添加 Controller 接口1.3.3.1 order模块1234567891011121314@RestController@RequestMapping(&quot;/order&quot;)public class OrderController &#123; @Autowired private RestTemplate restTemplate; @GetMapping(&quot;/add&quot;) public String add() &#123; System.out.println(&quot;下单成功&quot;); String msg = restTemplate.getForObject(&quot;http://127.0.0.1:8011/stock/reduce&quot;, String.class); return &quot;Hello World &quot; + msg; &#125;&#125; 1.3.3.2 stock 模块12345678910@RestController@RequestMapping(&quot;stock&quot;)public class StockController &#123; @GetMapping(&quot;reduce&quot;) public String reduce() &#123; System.out.println(&quot;扣减库存&quot;); return &quot;扣减库存&quot;; &#125;&#125; 1.3.3.3 调用运行 order 模块和 stock 模块，在浏览器中请求 http://localhost:8010/order/add 二、Spring Cloud Alibab 环境搭建2.1 版本说明最新版可以在此地址查看：https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E 2.1.1 毕业版本依赖关系(推荐使用)2.1.1.1 2022.x 分支适配 Spring Boot 3.0，Spring Cloud 2022.x 版本及以上的 Spring Cloud Alibaba 版本按从新到旧排列如下表（最新版本用*标记）： (注意，该分支 Spring Cloud Alibaba 版本命名方式进行了调整，未来将对应 Spring Cloud 版本，前三位为 Spring Cloud 版本，最后一位为扩展版本，比如适配 Spring Cloud 2022.0.0 版本对应的 Spring Cloud Alibaba 第一个版本为：2022.0.0.0，第个二版本为：2022.0.0.1，依此类推) Spring Cloud Alibaba Version Spring Cloud Version Spring Boot Version 2022.0.0.0* Spring Cloud 2022.0.0 3.0.2 2022.0.0.0-RC2 Spring Cloud 2022.0.0 3.0.2 2022.0.0.0-RC1 Spring Cloud 2022.0.0 3.0.0 2.1.1.2 2021.x 分支适配 Spring Boot 2.4，Spring Cloud 2021.x 版本及以上的 Spring Cloud Alibaba 版本按从新到旧排列如下表（最新版本用*标记）： Spring Cloud Alibaba Version Spring Cloud Version Spring Boot Version 2021.0.5.0* Spring Cloud 2021.0.5 2.6.13 2021.0.4.0 Spring Cloud 2021.0.4 2.6.11 2021.0.1.0 Spring Cloud 2021.0.1 2.6.3 2021.1 Spring Cloud 2020.0.1 2.4.2 2.1.1.3 2.2.x 分支适配 Spring Boot 为 2.4，Spring Cloud Hoxton 版本及以下的 Spring Cloud Alibaba 版本按从新到旧排列如下表（最新版本用*标记）： Spring Cloud Alibaba Version Spring Cloud Version Spring Boot Version 2.2.10-RC1* Spring Cloud Hoxton.SR12 2.3.12.RELEASE 2.2.9.RELEASE Spring Cloud Hoxton.SR12 2.3.12.RELEASE 2.2.8.RELEASE Spring Cloud Hoxton.SR12 2.3.12.RELEASE 2.2.7.RELEASE Spring Cloud Hoxton.SR12 2.3.12.RELEASE 2.2.6.RELEASE Spring Cloud Hoxton.SR9 2.3.2.RELEASE 2.2.1.RELEASE Spring Cloud Hoxton.SR3 2.2.5.RELEASE 2.2.0.RELEASE Spring Cloud Hoxton.RELEASE 2.2.X.RELEASE 2.1.4.RELEASE Spring Cloud Greenwich.SR6 2.1.13.RELEASE 2.1.2.RELEASE Spring Cloud Greenwich 2.1.X.RELEASE 2.0.4.RELEASE(停止维护，建议升级) Spring Cloud Finchley 2.0.X.RELEASE 1.5.1.RELEASE(停止维护，建议升级) Spring Cloud Edgware 1.5.X.RELEASE 2.1.2 组件版本关系每个 Spring Cloud Alibaba 版本及其自身所适配的各组件对应版本如下表所示（注意，Spring Cloud Dubbo 从 2021.0.1.0 起已被移除出主干，不再随主干演进）： Spring Cloud Alibaba Version Sentinel Version Nacos Version RocketMQ Version Dubbo Version Seata Version 2022.0.0.0 1.8.6 2.2.1 4.9.4 ~ 1.7.0 2022.0.0.0-RC2 1.8.6 2.2.1 4.9.4 ~ 1.7.0-native-rc2 2021.0.5.0 1.8.6 2.2.0 4.9.4 ~ 1.6.1 2.2.10-RC1 1.8.6 2.2.0 4.9.4 ~ 1.6.1 2022.0.0.0-RC1 1.8.6 2.2.1-RC 4.9.4 ~ 1.6.1 2.2.9.RELEASE 1.8.5 2.1.0 4.9.4 ~ 1.5.2 2021.0.4.0 1.8.5 2.0.4 4.9.4 ~ 1.5.2 2.2.8.RELEASE 1.8.4 2.1.0 4.9.3 ~ 1.5.1 2021.0.1.0 1.8.3 1.4.2 4.9.2 ~ 1.4.2 2.2.7.RELEASE 1.8.1 2.0.3 4.6.1 2.7.13 1.3.0 2.2.6.RELEASE 1.8.1 1.4.2 4.4.0 2.7.8 1.3.0 2021.1 or 2.2.5.RELEASE or 2.1.4.RELEASE or 2.0.4.RELEASE 1.8.0 1.4.1 4.4.0 2.7.8 1.3.0 2.2.3.RELEASE or 2.1.3.RELEASE or 2.0.3.RELEASE 1.8.0 1.3.3 4.4.0 2.7.8 1.3.0 2.2.1.RELEASE or 2.1.2.RELEASE or 2.0.2.RELEASE 1.7.1 1.2.1 4.4.0 2.7.6 1.2.0 2.2.0.RELEASE 1.7.1 1.1.4 4.4.0 2.7.4.1 1.0.0 2.1.1.RELEASE or 2.0.1.RELEASE or 1.5.1.RELEASE 1.7.0 1.1.4 4.4.0 2.7.3 0.9.0 2.1.0.RELEASE or 2.0.0.RELEASE or 1.5.0.RELEASE 1.6.3 1.1.1 4.4.0 2.7.3 0.7.1 2.2 本项目中使用的版本 Spring Boot：2.7.14 Spring Cloud：2021.0.5 Spring Cloud Alibaba：2021.0.5.0 2.3 在父工程中添加 Spring Cloud Alibab依赖因为我们之前已经添加过SpringBoot管理器，所以不能再使用这种方式来添加 Spring Cloud Alibaba 的管理器 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.14&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; 可以采用如下方式，在父工程的 pom.xml 文件中添加如下内容: 1234567891011&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2021.0.5.0&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 也可以把 SpringBoot 的管理器也放在这里面，再加上 Spring Cloud 的版本管理，最终写法如下： 12345678910111213141516171819202122232425262728&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- springboot 的版本管理器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.14&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud Alibaba 的版本管理 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2021.0.5.0&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud 的版本管理 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;2021.0.5&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 三、Alibaba 微服务组件 Nacos 注册中心3.1 什么是 Nacos官方：一个更易于构建云原生应用的动态服务发现（Nacos Discovery）、服务配置（Nacos Config）和服务管理平台。 集 注册中心+配置中心+服务管理 平台 Nacos 的关键特性包括： 服务发现和服务健康监测 动态配置服务 动态 DNS 服务 服务及其元数据管理 3.2 核心功能 服务注册：Nacos Client 会通过发送 REST 请求的方式向 Nacos Server 注册自己的服务，提供自身的元数据，比如 ip 地址、端口等信息。Nacos Server 接收到注册请求后，就会把这些元数据信息存储在一个双层的内存 Map 中。 服务心跳：在服务注册后，Nacos Client 会维护一个定时心跳来持续通知 Nacos Server，说明服务一直处于可用状态，防止被剔除。默认 5s 发送一次心跳。 服务同步：Nacos Server 集群之间会相互同步服务实例，用来保证服务信息的一致性。 leader raft 服务发现：服务消费者（Nacos Client）在调用服务提供者的服务时，会发送一个 REST 请求给 Nacos Server，获取上面注册的服务清单，并且缓存在在 Nacos Client 本地，同时会在 Nacos Client 本地启动一个定时任务定时拉取服务端最新的注册表信息更新到本地缓存。 服务健康检查：Nacos Server 会开启一个定时任务用来检查注册服务实例的健康情况，对于超过 15s 没有收到客户端心跳的实例会将它的 healthy 属性置为 false（客户端服务发现时不会发现），如果某个实例超过 30s 没有收到心跳，直接剔除该实例（被剔除的实例如果恢复发送心跳则会重新注册）。 3.3 Nacos Server 单机部署3.3.1 下载3.3.1.1 下载源码编译源码下载地址：https://github.com/alibaba/nacos 123cd nacosmvn -Prelease-nacos clean install -Ucd nacos/distribution/target 3.3.1.2 下载安装包下载地址：https://github.com/alibaba/nacos/releases 3.3.2 启动 Nacos Server此处以 Windows 为例，双击 startup.cmd 运行 但是默认是集群模式，此处我们先将其改成单机模式再运行，编辑 startup.cmd ，将下面的 cluster 修改为 standalone 双击 startup.cmd，看到如下输出代表启动成功 访问 http://localhost:8848/nacos/index.html 即可登录 web 控制台。默认的用户名和密码都是 nacos 3.4 搭建 Nacos Client3.4.1 修改之前创建的项目为了不影响我们之前创建的两个子模块，我们在这里重新创建这两个模块。 复制之前创建的 order 和 stock 两个模块，分别复制为 order-nacos 和 stock-nacos，并做一些修改。 修改两个模块的 pom.xml 文件，将 artifactId 分别修改为 &lt;artifactId&gt;order-nacos&lt;/artifactId&gt; 和 &lt;artifactId&gt;stock-nacos&lt;/artifactId&gt; 然后在父工程的 pom.xml 文件的 &lt;modules&gt; 下添加两个 module：&lt;module&gt;order-nacos&lt;/module&gt; 和 &lt;module&gt;stock-nacos&lt;/module&gt; 然后点击 Maven，刷新一下即可 3.4.2 引入 nacos-discovery 依赖3.4.2.1 添加依赖在 order-nacos 和 stock-nacos 的 pom.xml 文件中添加 nacos-discovery 的依赖： 12345&lt;!-- nacos 服务注册发现 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt; 3.4.2.2 修改配置文件在 application.yml 文件中添加相关配置。 order-nacos： 123456789101112131415server: port: 8020spring: application: # 应用名称 （nacos 会将该名称当作服务名称） name: order-service cloud: nacos: server-addr: 127.0.0.1:8848 discovery: username: nacos password: nacos namespace: public stock-nacos： 123456789101112131415server: port: 8021spring: application: # 应用名称 （nacos 会将该名称当作服务名称） name: stock-service cloud: nacos: server-addr: 127.0.0.1:8848 discovery: username: nacos password: nacos namespace: public 3.4.2.3 常见配置项 配置项 Key 默认值 说明 服务端地址 spring.cloud.nacos.discovery.server-addr 无 Nacos Server 启动监听的ip地址和端口 服务名 spring.cloud.nacos.discovery.service $&#123;spring.application.name&#125; 给当前的服务命名 服务分组 spring.cloud.nacos.discovery.group DEFAULT_GROUP 设置服务所处的分组 权重 spring.cloud.nacos.discovery.weight 1 取值范围 1 到 100，数值越大，权重越大 网卡名 spring.cloud.nacos.discovery.network-interface 无 当IP未配置时，注册的IP为此网卡所对应的IP地址，如果此项也未配置，则默认取第一块网卡的地址 注册的IP地址 spring.cloud.nacos.discovery.ip 无 优先级最高 注册的端口 spring.cloud.nacos.discovery.port -1 默认情况下不用配置，会自动探测 命名空间 spring.cloud.nacos.discovery.namespace 无 常用场景之一是不同环境的注册的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。 AccessKey spring.cloud.nacos.discovery.access-key 无 当要上阿里云时，阿里云上面的一个云账号名 SecretKey spring.cloud.nacos.discovery.secret-key 无 当要上阿里云时，阿里云上面的一个云账号密码 Metadata spring.cloud.nacos.discovery.metadata 无 使用Map格式配置，用户可以根据自己的需要自定义一些和服务相关的元数据信息 日志文件名 spring.cloud.nacos.discovery.log-name 无 集群 spring.cloud.nacos.discovery.cluster-name DEFAULT 配置成Nacos集群名称 接入点 spring.cloud.nacos.discovery.enpoint UTF-8 地域的某个服务的入口域名，通过此域名可以动态地拿到服务端地址 是否集成Ribbon ribbon.nacos.enabled true 一般都设置成true即可 是否开启Nacos Watch spring.cloud.nacos.discovery.watch.enabled true 可以设置成false来关闭 watch 注册的IP地址类型 spring.cloud.nacos.discovery.ip-type IPv4 可以配置IPv4和IPv6两种类型 3.4.3 运行运行 order-nacos 和 stock-nacos，然后查看 nacos 的 web 控制台，可以看到这两个服务： 3.4.4 改造 order-nacos 调用 stock-nacos 的方式3.4.4.1 给 order-nacos 添加负载均衡这一步很重要，因为不添加负载均衡的话是无法调用其他服务的 12345&lt;!-- 高版本的不使用Netflix了，所以不用Ribbon来实现负载均衡，因此需要添加负载均衡的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;&lt;/dependency&gt; 修改 order-nacos 启动类中的 RestTemplate，在 RestTemplate 上添加 @LoadBalanced 注解。 12345@Bean@LoadBalancedpublic RestTemplate restTemplate(RestTemplateBuilder builder) &#123; return builder.build();&#125; 3.4.4.2 修改 order-nacos 模块的 OrderController 类中的 add 方法：将 stock-nacos 的服务地址修改为服务名 stock-service 1234567@GetMapping(&quot;/add&quot;)@LoadBalancedpublic String add() &#123; System.out.println(&quot;下单成功&quot;); String msg = restTemplate.getForObject(&quot;http://stock-service/stock/reduce&quot;, String.class); return &quot;Hello World &quot; + msg;&#125; 重启 order-nacos 服务，再次请求 http://localhost:8010/order/add，也可以请求成功。 3.5 Nacos Server 集群部署下面介绍在 Linux 上安装 Nacos Server 并搭建集群的步骤。 3.5.1 下载Nacos Server下载地址：https://github.com/alibaba/nacos/releases/download/2.2.0/nacos-server-2.2.0.tar.gz 3.5.2 安装 Nacos Server将下载好的安装包上传到 /opt/nacos 目录 12345678cd /opt/nacos# 解压，解压后得到 nacos 目录tar -zxvf nacos-server-2.2.0.tar.gz# 因为要在一台机器上装多个，所以将解压出来的目录重命名# nacos2.x新增两个通信端口，会占用连续的两个端口（与主端口的偏移量分别为+1000和+1001），所以这里不要配置连续的端口，端口之间至少留出一个端口cp -r nacos nacos8849cp -r nacos nacos8851mv nacos nacos8853 3.5.3 修改配置文件以 nacos8849 为例，进入 nacos8849 目录。修改 conf/application.properties 文件的配置，使用外置数据源，要使用 mysql5.7+ 123456789101112# web 服务端口server.port=8849# 使用外置 MySQL 数据源spring.datasource.platform=mysql### Count of DB:db.num=1### Connect URL of DB:db.url.0=jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC&amp;allowPublicKeyRetrieval=truedb.user.0=rootdb.password.0=123456 nacos8851 和 nacos8853 中也作相同修改，注意 server.port 要对应修改。 3.5.4 修改 cluster.conf将 conf/cluster.conf.example 复制为 conf/cluster.conf ，添加节点配置 nacos8849、nacos8851 和 nacos8853 的此文件都是相同的。 3.5.5 创建 MySQL 数据库3.5.5.1 安装 MySQL如果还未安装 MySQL，可以参考以下在 docker 中安装 MySQL的步骤： 12345678910# 拉取 MySQL 镜像，不加版本号默认下载 latest 版本，即 docker pull mysql:latestdocker pull mysql# mysql 的配置目录mkdir -p /opt/docker/mysql/conf# mysql 的日志目录mkdir -p /opt/docker/mysql/logs# mysql 的数据目录mkdir -p /opt/docker/mysql/data# 使用 mysql:latest 镜像创建容器docker run -p 3306:3306 --name mysql --privileged=true -v /opt/docker/mysql/conf:/etc/mysql/conf.d -v /opt/docker/mysql/logs:/logs -v /opt/docker/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:latest 命令说明： -p 3306:3306将宿主机的 3306 端口映射到 docker 容器的 3306 端口，格式为：主机(宿主)端口:容器端口 --name mysql运行服务的名字 -v /opt/docker/mysql/conf:/etc/mysql/conf.d将宿主机 /opt/docker/mysql 目录下的 /conf 挂载到容器的 /etc/mysql/conf.d -v /opt/docker/mysql/logs:/logs将宿主机 /opt/docker/mysql 目录下的 /logs 目录挂载到容器的 /logs -v /opt/docker/mysql/data:/var/lib/mysql将宿主机 /opt/docker/mysql 目录下的 /data 目录挂载到容器的 /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456初始化 root 用户的密码为 123456 -d mysql:latest后台程序运行 mysql 3.5.5.2 创建数据库表1234567891011# 进入 MySQL 容器docker exec -it &lt;%CONTAINER ID%&gt; /bin/bash# 执行以下命令，然后输入密码mysql -uroot -p# 创建数据库create database nacos_config default CHARACTER set utf8mb4 collate utf8mb4_0900_ai_ci;# 切换数据库use nacos_config;# .sql 文件在 nacos 安装目录下的 conf/mysql-schema.sql# 执行 .sql 文件，我的文件放在宿主机的 /opt/docker/mysql/data/目录下面，对应 docker 中的 /var/lib/mysql/ 目录SOURCE /var/lib/mysql/mysql-schema.sql; 3.5.6 如果出现内存不足，修改启动脚本JVM参数1JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms512m -Xmx512m -Xmn256m -XX:MetaspaceSize=64m -XX:MaxMetaspaceSize=128m&quot; 3.5.7 启动 nacos123456# 进入启动程序所在目录cd nacos8849/bin# 执行启动命令./startup.sh# 查看启动日志tailf ../logs/start.out 在 nacos8851 和 nacos8853 中也执行相同的操作. 启动完毕后，登录任一节点的 web 控制台，可以看到集群中的所有节点。 3.5.8 使用 nginx 访问 nacos 集群现在集群已经搭建完成，但是我们去访问节点的时候还是通过各个节点的 ip 去访问的，这显然不合适，所以我们需要使用一个 ip 就能访问到各个节点，这里我们通过 nginx 来实现。 3.5.8.1 安装 nginx123456789101112131415161718192021222324# ------ 安装 nginx 依赖yum install -y gcc-c++yum install -y pcre pcre-devel yum install -y zlib zlib-develyum install -y openssl openssl-devel# ------ 下载并解压 nginx 安装包cd /usr/localmkdir nginxcd nginx# 下载 nginxwget http://nginx.org/download/nginx-1.20.1.tar.gztar -zxvf nginx-1.20.1.tar.gz# 安装 nginx 其他模块yum -y install epel-releaseyum -y install nginx-all-modules.noarch# ------ 安装 nginx# 进入nginx目录cd /usr/local/nginx/nginx-1.20.1# 编译 执行命令 考虑到后续安装ssl证书 添加两个模块 如不需要直接执行./configure即可./configure --with-http_stub_status_module --with-http_ssl_module --with-stream=dynamic# 执行make命令(要是执行不成功请检查最开始安装的四个依赖有没有安装成功)make# 执行make install命令make install 3.5.8.2 编辑 nginx 配置文件vim /usr/local/nginx/conf/nginx.conf 1234567891011121314upstream nacos &#123; server 192.168.204.130:8849; server 192.168.204.130:8851; server 192.168.204.130:8853;&#125;server &#123; listen 8847; server_name localhost; location /nacos &#123; proxy_pass http://nacos; &#125;&#125; 3.5.8.3 启动 nginx123cd /usr/local/nginx/sbin# 指定配置文件启动./nginx -c /usr/local/nginx/conf/nginx.conf 访问 ip:8847/nacos ，也能正常看到集群中的各个节点。","categories":[{"name":"Java","slug":"Java","permalink":"https://itdh.github.io/categories/Java/"},{"name":"框架","slug":"Java/框架","permalink":"https://itdh.github.io/categories/Java/%E6%A1%86%E6%9E%B6/"},{"name":"Spring Cloud","slug":"Java/框架/Spring-Cloud","permalink":"https://itdh.github.io/categories/Java/%E6%A1%86%E6%9E%B6/Spring-Cloud/"}],"tags":[]},{"title":"PostgreSQL定位问题时常用SQL","slug":"PostgreSQL定位问题时常用SQL","date":"2023-08-01T06:21:30.000Z","updated":"2023-08-01T06:52:52.216Z","comments":true,"path":"posts/f1ecacbb.html","link":"","permalink":"https://itdh.github.io/posts/f1ecacbb.html","excerpt":"","text":"一、查看当前正在运行的 SQL1.1 SQL 语句123456789101112131415161718SELECT procpid, start, now() - start AS lap, current_query FROM (SELECT backendid, pg_stat_get_backend_pid(S.backendid) AS procpid, pg_stat_get_backend_activity_start(S.backendid) AS start, pg_stat_get_backend_activity(S.backendid) AS current_query FROM (SELECT pg_stat_get_backend_idset() AS backendid) AS S ) AS S WHERE current_query &lt;&gt; &#x27;idle&#x27; ORDER BY lap DESC; 1.2 字段说明 字段名 说明 procpid 进程 id start 进程开始时间 lap 经过时间 current_query 执行中的 SQL 1.3 停止正在执行的 SQL1.3.1 方法一1SELECT pg_cancel_backend(进程id); 1.3.2 方法二使用系统命令 kill -9 进程id 二、查看当前事务锁等待、持锁信息的 SQL2.1 SQL 语句1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465with t_wait as ( select a.mode,a.locktype,a.database,a.relation,a.page,a.tuple,a.classid,a.granted, a.objid,a.objsubid,a.pid,a.virtualtransaction,a.virtualxid,a.transactionid,a.fastpath, b.state,b.query,b.xact_start,b.query_start,b.usename,b.datname,b.client_addr,b.client_port,b.application_name from pg_locks a,pg_stat_activity b where a.pid=b.pid and not a.granted ), t_run as ( select a.mode,a.locktype,a.database,a.relation,a.page,a.tuple,a.classid,a.granted, a.objid,a.objsubid,a.pid,a.virtualtransaction,a.virtualxid,a.transactionid,a.fastpath, b.state,b.query,b.xact_start,b.query_start,b.usename,b.datname,b.client_addr,b.client_port,b.application_name from pg_locks a,pg_stat_activity b where a.pid=b.pid and a.granted ), t_overlap as ( select r.* from t_wait w join t_run r on ( r.locktype is not distinct from w.locktype and r.database is not distinct from w.database and r.relation is not distinct from w.relation and r.page is not distinct from w.page and r.tuple is not distinct from w.tuple and r.virtualxid is not distinct from w.virtualxid and r.transactionid is not distinct from w.transactionid and r.classid is not distinct from w.classid and r.objid is not distinct from w.objid and r.objsubid is not distinct from w.objsubid and r.pid &lt;&gt; w.pid ) ), t_unionall as ( select r.* from t_overlap r union all select w.* from t_wait w ) select locktype,datname,relation::regclass,page,tuple,virtualxid,transactionid::text,classid::regclass,objid,objsubid, string_agg( &#x27;Pid: &#x27;||case when pid is null then &#x27;NULL&#x27; else pid::text end||chr(10)|| &#x27;Lock_Granted: &#x27;||case when granted is null then &#x27;NULL&#x27; else granted::text end||&#x27; , Mode: &#x27;||case when mode is null then &#x27;NULL&#x27; else mode::text end||&#x27; , FastPath: &#x27;||case when fastpath is null then &#x27;NULL&#x27; else fastpath::text end||&#x27; , VirtualTransaction: &#x27;||case when virtualtransaction is null then &#x27;NULL&#x27; else virtualtransaction::text end||&#x27; , Session_State: &#x27;||case when state is null then &#x27;NULL&#x27; else state::text end||chr(10)|| &#x27;Username: &#x27;||case when usename is null then &#x27;NULL&#x27; else usename::text end||&#x27; , Database: &#x27;||case when datname is null then &#x27;NULL&#x27; else datname::text end||&#x27; , Client_Addr: &#x27;||case when client_addr is null then &#x27;NULL&#x27; else client_addr::text end||&#x27; , Client_Port: &#x27;||case when client_port is null then &#x27;NULL&#x27; else client_port::text end||&#x27; , Application_Name: &#x27;||case when application_name is null then &#x27;NULL&#x27; else application_name::text end||chr(10)|| &#x27;Xact_Start: &#x27;||case when xact_start is null then &#x27;NULL&#x27; else xact_start::text end||&#x27; , Query_Start: &#x27;||case when query_start is null then &#x27;NULL&#x27; else query_start::text end||&#x27; , Xact_Elapse: &#x27;||case when (now()-xact_start) is null then &#x27;NULL&#x27; else (now()-xact_start)::text end||&#x27; , Query_Elapse: &#x27;||case when (now()-query_start) is null then &#x27;NULL&#x27; else (now()-query_start)::text end||chr(10)|| &#x27;SQL (Current SQL in Transaction): &#x27;||chr(10)|| case when query is null then &#x27;NULL&#x27; else query::text end, chr(10)||&#x27;--------&#x27;||chr(10) order by ( case mode when &#x27;INVALID&#x27; then 0 when &#x27;AccessShareLock&#x27; then 1 when &#x27;RowShareLock&#x27; then 2 when &#x27;RowExclusiveLock&#x27; then 3 when &#x27;ShareUpdateExclusiveLock&#x27; then 4 when &#x27;ShareLock&#x27; then 5 when &#x27;ShareRowExclusiveLock&#x27; then 6 when &#x27;ExclusiveLock&#x27; then 7 when &#x27;AccessExclusiveLock&#x27; then 8 else 0 end ) desc, (case when granted then 0 else 1 end) ) as lock_conflict from t_unionall group by locktype,datname,relation,page,tuple,virtualxid,transactionid::text,classid,objid,objsubid ; 2.2 字段说明 字段名 说明 locktype 被锁定的对象类型：relation、extend、page、tuple、transactionid、virtualxid、object、userlock、advisory datname 数据库名 relation 如果对象不是表或只是表的一部分，则此值为“NULL”，否则此值是表的OID page 表中的页号，如果对象不是表行（tuple）或表页（relation page），则此值为“NULL” tuple 页内的行号（tuple） virtualxid 虚拟事务id transactionid 事务id classid 包含该对象系统目录的id objid 对象在系统目录的oid objsubid 如果对象是表列（table column），此列的值为列号，这时classid和objid指向表","categories":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://itdh.github.io/categories/PostgreSQL/"}],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://itdh.github.io/tags/PostgreSQL/"}]},{"title":"使用docker-compose安装常用中间件","slug":"使用docker-compose安装常用中间件","date":"2023-06-09T07:23:32.000Z","updated":"2023-08-01T06:53:11.233Z","comments":true,"path":"posts/a524c0bb.html","link":"","permalink":"https://itdh.github.io/posts/a524c0bb.html","excerpt":"","text":"本文主要介绍使用 docker-compose 安装 Redis、Elasticsearch、RabbitMQ、PostgreSQL 这几个组件。 一、环境准备首先需要安装 docker 并启动 12yum install -y docker-cesystemctl start docker 然后需要安装 docker-compose 可以去 github 上下载 docker-compose，将下载的二进制文件放在 /usr/local/bin 目录，然后修改文件权限 1chmod 755 /usr/local/bin/docker-compose 然后输入 docker-compose -v 验证 二、拉取镜像此处使用的几个组件版本分别为： ElasticSearch：2.4.6 Redis：7.0.4 RabbitMQ：latest PostgreSQL：9.6.21 ElasticSearch 、Redis、PostgreSQL 指定了版本号，RabbitMQ 未指定，使用了最新版本。 1234docker pull elasticsearch:2.4.6docker pull redis:7.0.4docker pull rabbitmqdocker pull postgres:9.6.21 三、编辑 docker-compose.yml创建一个 docker-compose.yml 文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576version: &#x27;3.9&#x27;services: elasticsearch: image: elasticsearch:2.4.6 container_name: es-2.4.6-ssl privileged: true #总是重启后启动 #restart: always environment: - &quot;cluster.name=es-dh&quot; #设置集群名称为es-dh - &quot;discovery.type=single-node&quot; #以单一节点模式启动 - &quot;ES_JAVA_OPTS=-Xms128m -Xmx1024m&quot; #设置使用jvm内存大小 - bootstrap.memory_lock=true volumes: - /dh/volumes/es/es-2.4.6-ssl/plugins:/usr/share/elasticsearch/plugins #插件文件挂载 - /dh/volumes/es/es-2.4.6-ssl/data:/usr/share/elasticsearch/data:rw #数据文件挂载 - /dh/volumes/es/es-2.4.6-ssl/logs:/user/share/elasticsearch/logs:rw #日志文件挂载 - /dh/volumes/es/es-2.4.6-ssl/elasticsearch.yml:/etc/elasticsearch/elasticsearch.yml #配置文件挂载 ports: - 9200:9200 - 9300:9300 es-head: image: elasticsearch-head:5 container_name: es-head-5 ports: - 9100:9100 rabbitmq: container_name: rabbitmq image: rabbitmq:latest privileged: true ports: - 5672:5672 - 15672:15672 volumes: - /dh/volumes/rabbitmq/:/var/lib/rabbitmq - /dh/volumes/rabbitmq/rabbitmq.ssl.config:/etc/rabbitmq/rabbitmq.config environment: - RABBITMQ_DEFAULT_VHOST=/ - RABBITMQ_DEFAULT_USER=dh - RABBITMQ_DEFAULT_PASS=dh redis: image: redis:7.0.4 container_name: redis-7.0.4-ssl privileged: true volumes: - /dh/volumes/redis/redis-7.0.4-ssl/data:/data - /dh/volumes/redis/redis-7.0.4-ssl:/var/lib/redis - /dh/volumes/redis/redis-7.0.4-ssl/redis.conf:/etc/redis/redis.conf #- /dh/volumes/redis/redis-7.0.4-ssl/logs/redis.log:/var/log/redis/redis.log - /var/lib/redis/server.crt:/var/lib/redis/server.crt - /var/lib/redis/server.key:/var/lib/redis/server.key - /var/lib/redis/ca.crt:/var/lib/redis/ca.crt command: [&quot;redis-server&quot;,&quot;/etc/redis/redis.conf&quot;] ports: - 6379:6379 postgres: image: postgres:9.6.21 privileged: true container_name: postgresql-9.6.21-ssl ports: - 5433:5432 environment: POSTGRES_PASSWORD: postgres PGDATA: /var/lib/pgsql/9.6/data/ volumes: - /dh/volumes/pgsql/pgsql-9.6.21-ssl/data:/var/lib/pgsql/9.6/data/ - /dh/volumes/pgsql/server.crt:/var/lib/pgsql/server.crt - /dh/volumes/pgsql/server.key:/var/lib/pgsql/server.key - /dh/volumes/pgsql/ca.crt:/var/lib/pgsql/ca.crt 从上面可以看到我们挂载了一些文件和目录，对于挂载的文件，需要修改其权限为 777。 需要注意：对于 PostgreSQL需要特殊处理，我们将宿主机的 &#x2F;dh&#x2F;volumes&#x2F;pgsql&#x2F;pgsql-9.6.21-ssl&#x2F;data 目录挂载到容器的 &#x2F;var&#x2F;lib&#x2F;pgsql&#x2F;9.6&#x2F;data&#x2F; 目录，宿主机的这个目录必须是一个空目录，否则 PostgreSQL 会启动失败，如果我们想修改配置文件，可以等容器启动后再修改配置文件，然后重启 PostgreSQL。 由于我们给 PostgreSQL 开启了SSL并挂在了 证书文件，但是 PostgreSQL 的证书文件权限必须为 600 （database user）或 640（root），所以此处我们如果给这三个文件777的权限同样会启动失败，此时我们可以看看挂载的目录里的文件所属用户和所属组，使用chown将这三个证书文件的所属组和用户修改成一样的，并修改权限为600。 四、启动执行 docker-compose up -d 启动该文件中定义的所有容器。 如果想删除所有容器，可以执行 docker-compose down 删除所有已停止的容器，docker-compose rm --stop 删除某个已停止的容器，docker-compose rm --stop $&#123;server_name&#125; 删除某个正在运行的容器， docker-compose rm -f $&#123;service_name&#125; 如果想单独创建某个容器，执行 docker-compose up -d $&#123;server_name&#125; 如果想单独启动或停止某个容器 ，执行 docker-compose start/stop $&#123;server_name&#125; 五、常见问题5.1 开启 rabbitmq web管理端进入容器，执行 rabbitmq-plugins enable rabbitmq_management 此时访问管理页面，点击 Channels 可能会报错，解决办法： ①查看配置文件 1cat /etc/rabbitmq/conf.d/management_agent.disable_metrics_collector.conf 注意：文件名可能不是management_agent.disable_metrics_collector.conf，可能是xx-management_agent.disable_metrics_collector.conf，具体的可以看这个目录下面的实际文件名。 ②将配置文件中的 true 修改成 false 1echo management_agent.disable_metrics_collector = false &gt; /etc/rabbitmq/conf.d/management_agent.disable_metrics_collector.conf 然后退出容器，重启 rabbitmq","categories":[{"name":"docker","slug":"docker","permalink":"https://itdh.github.io/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://itdh.github.io/tags/docker/"},{"name":"docker-compose","slug":"docker-compose","permalink":"https://itdh.github.io/tags/docker-compose/"}]},{"title":"使用 IDEA 构建 Spring5.3.10 源码","slug":"使用-IDEA-构建-Spring5-3-10-源码","date":"2023-06-02T02:56:32.000Z","updated":"2023-06-06T12:10:29.100Z","comments":true,"path":"posts/983a1c52.html","link":"","permalink":"https://itdh.github.io/posts/983a1c52.html","excerpt":"","text":"此教程是基于周瑜老师的 Spring5.3.10 注释版源码编译的，并不是 Github 原生的 Spring5.3.10 源码，有一些差别，但都是 gradle 配置文件的微小改动，比如把某些依赖从 optional 改成 compile 级别、修改了 gradle 仓库的地址（主要是为了方便编译），其他都没改动。 一、版本 Spring 版本：5.3.10 Gradle 版本：6.8 IDEA 版本：2022.2 二、下载Spring源码所需要的依赖因为Spring源码存在很多依赖包，如果自行下载，会需要下很久，所以此处将我自己电脑上已下载的依赖给出： 链接：https://caiyun.139.com/m/i?005CiN4dFp6mN 提取码：TbOy 三、下载 Spring 源码git clone 的地址为：https://gitee.com/dhpro/spring-framework-5.3.10.git 建议直接用 IDEA 的 git 来下载源码： 输入地址，点击 Clone，就会开始下载源码工程（因为是从 gitee 上下载，所以会比从 github 上下载快很多)。 一旦下载完成，IDEA 就会自动下载 gradle，下载完 gradle 就会开始下载 Spring 源码依赖，但是我们已经有现成的了，所以可以直接取消这个过程。 四、修改IDEA的gradle配置 首先把 gradle user home 改为 .gradle压缩包 的解压之后的文件路径， 然后把 Build and run using 和 Run tests using 都改为 IntelliJ IDEA， 改完之后点击 Apply，再点击 OK，会自动触发 gradle 的重新编译。 五、运行代码编译成功后，在左侧可以看到如下模块，其中有一个 tuling 模块，这是一个可以直接运行的模块，在它下面有一个 Test 类，直接运行 main 方法。 5.1 运行过程中可能出现的问题5.1.1 问题一我在运行的时候出现了以下错误： 由于报错的是 core 模块，所以在 gradle 中找到 core 模块，先执行 clean，然后 build，执行完毕后重新运行程序，问题解决。","categories":[{"name":"Java","slug":"Java","permalink":"https://itdh.github.io/categories/Java/"},{"name":"框架","slug":"Java/框架","permalink":"https://itdh.github.io/categories/Java/%E6%A1%86%E6%9E%B6/"},{"name":"Spring","slug":"Java/框架/Spring","permalink":"https://itdh.github.io/categories/Java/%E6%A1%86%E6%9E%B6/Spring/"},{"name":"Spring-5.3.10","slug":"Java/框架/Spring/Spring-5-3-10","permalink":"https://itdh.github.io/categories/Java/%E6%A1%86%E6%9E%B6/Spring/Spring-5-3-10/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://itdh.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://itdh.github.io/tags/Spring/"}]},{"title":"Arthas","slug":"Arthas","date":"2023-06-01T07:35:46.000Z","updated":"2023-06-02T06:43:40.215Z","comments":true,"path":"posts/e1a71cf6.html","link":"","permalink":"https://itdh.github.io/posts/e1a71cf6.html","excerpt":"","text":"一、简介1.1 什么是 ArthasArthas 是一款线上监控诊断产品，通过全局视角实时查看应用 load、内存、gc、线程的状态信息，并能在不修改应用代码的情况下，对业务问题进行诊断，包括查看方法调用的出入参、异常，监测方法执行耗时，类加载信息等，大大提升线上问题排查效率。 1.2 下载 Arthas下载地址：https://arthas.aliyun.com/download/latest_version?mirror=aliyun 1.3 启动方式将下载的文件解压后，可以看到有 as.sh和 arthas-boot.jar，有两种启动方式 直接执行 ./as.sh启动 执行 java -jar arthas-boot.jar启动 需要注意的是：使用和目标进程一致的用户启动，否则可能 attach 失败 执行该程序的用户需要和目标进程具有相同的权限。比如以 admin用户来执行：sudo su admin &amp;&amp; java -jar arthas-boot.jar或 sudo -u admin -EH java -jar arthas-boot.jar。 如果 attach 不上目标进程，可以查看~/logs/arthas/目录下的日志。 执行成功后会显示 Java 进程信息，输入对应的数字序号后回车，Arthas 会 attach 到目标进程上，并输出日志。 二、命令列表及其使用2.1 JVM 相关2.1.1 dashboard - 当前系统的实时数据面板2.1.1.1 作用显示当前系统的实时数据面板，按 ctrl+c退出。 2.1.1.2 参数说明 参数名称 参数说明 [i:] 刷新实时数据的时间间隔 (ms)，默认 5000ms [n:] 刷新实时数据的次数 实例：dashboard -i 1000 -n 2 ：每1000ms刷新一次，刷新两次。 2.1.1.3 数据说明 ID: Java 级别的线程 ID，注意这个 ID 不能跟 jstack 中的 nativeID 一一对应。 NAME: 线程名 GROUP: 线程组名 PRIORITY: 线程优先级, 1~10 之间的数字，越大表示优先级越高 STATE: 线程的状态 CPU%: 线程的 cpu 使用率。比如采样间隔 1000ms，某个线程的增量 cpu 时间为 100ms，则 cpu 使用率&#x3D;100&#x2F;1000&#x3D;10% DELTA_TIME: 上次采样之后线程运行增量 CPU 时间，数据格式为秒 TIME: 线程运行总 CPU 时间，数据格式为分:秒 INTERRUPTED: 线程当前的中断位状态 DAEMON: 是否是 daemon 线程 从上图中可以看到有些线程的 ID、PRIORITY 为-1，且没有状态等属性，这是因为这些线程是 JVM 内部线程。 2.1.1.4 JVM 内部线程Java 8 之后支持获取 JVM 内部线程 CPU 时间，这些线程只有名称和 CPU 时间，没有 ID 及状态等信息（显示 ID 为-1）。 通过内部线程可以观测到 JVM 活动，如 GC、JIT 编译等占用 CPU 情况，方便了解 JVM 整体运行状况。 当 JVM 堆(heap)&#x2F;元数据(metaspace)空间不足或 OOM 时，可以看到 GC 线程的 CPU 占用率明显高于其他的线程。 当执行 trace/watch/tt/redefine等命令后，可以看到 JIT 线程活动变得更频繁。因为 JVM 热更新 class 字节码时清除了此 class 相关的 JIT 编译结果，需要重新编译。 JVM 内部线程包括下面几种： JIT 编译线程: 如 C2 CompilerThread0, C1 CompilerThread2 GC 线程: 如 GC Thread0, G1 Young RemSet Sampling 其它内部线程: 如 VM Periodic Task Thread, VM Thread, Service Thread 2.1.2 ognl - 执行 ognl 表达式2.1.2.1 作用执行 ognl 表达式 2.1.2.2 参数说明 参数名称 参数说明 express 执行的表达式 [c:] 执行表达式的 ClassLoader 的 hashcode，默认值是 SystemClassLoader [classLoaderClass:] 指定执行表达式的 ClassLoader 的 class name [x] 结果对象的展开层次，默认值 1 2.1.2.3 ognl 表达式说明2.1.2.3.1 语法基本的 OGNL 表达式非常简单。该语言的特性已经变得非常丰富，但是您通常不需要担心该语言中更复杂的部分：简单的情况仍然如此。例如，要获取对象的 name 属性，OGNL 表达式就是 name。要获取由 headline 属性返回的对象的 text 属性，OGNL 表达式是 headline.text。 OGNL 表达式的基本单元是导航链，通常简称为“链”。最简单的链条由以下部分组成： 表达式元素部分 例子 属性名称 比如上面示例中的 name和 headline.text。 方法调用 hashCode()返回当前对象的哈希码 数组索引 listeners[0]返回当前对象 listeners 列表中的第一个 所有 OGNL 表达式都在当前对象的上下文中求值，而链只是使用链中前一个链接的结果作为下一个链接的当前对象。你想把链条拉长多长都行。例如，这条链： 1name.toCharArray()[0].numericValue.toString() 这个表达式按照以下步骤进行计算： 提取初始或根对象（用户通过 OGNL 上下文提供给 OGNL ）的 name 属性； 在结果字符串上调用 toCharArray() 方法； 从结果数组中提取第一个字符（索引为0的字符）； 从该字符获取 numericValue 属性(字符表示为 Character对象，Character类有一个名为 getNumericValue() 的方法)。 在结果 Integer 对象上调用 toString()。这个表达式的最终结果是最后一次 toString() 调用返回的 String。 请注意，这个示例只能用于从对象获取值，而不能用于设置值。将上述表达式传递给 Ognl.setValue() 方法将导致InappropriateExpressionException被抛出，因为链中的最后一个链接既不是属性名也不是数组索引。 2.1.2.3.2 表达式本节概述了 OGNL 表达式元素的细节。 常量 OGNL 有以下几种常量： String 字面值，如 Java 中由单引号或双引号分隔，并带有完整的转义集； Character 字面量，也与 Java 一样：由单引号分隔，也带有全套转义； 数字字面值，比 Java 多一些类型。除了 Java 的整型、长型、浮点数和双精度外，OGNL 还允许您指定带有“b”或“b”后缀的 BigDecimals，以及带有“h”或“h”后缀的 BigIntegers(想想“huge”——我们选择了“h”表示)； Boolean：true 或者 false； null 引用属性 OGNL 在处理属性引用时以不同的方式对待不同类型的对象。映射将所有属性引用视为元素查找或存储，并将属性名称作为键。列表和数组类似地处理数字属性，以属性名作为索引，但处理字符串属性的方式与普通对象相同。普通对象（即所有其他类型的对象）只能通过使用“get”和“set”方法（或“is”和“set”）处理字符串属性，如果对象有这些方法，或者使用给定名称的字段处理字符串属性。 注意这里的新术语。属性“名称”可以是任何类型，而不仅仅是字符串。但是要引用非字符串属性，必须使用我们一直称为“索引”的符号。例如，要获取一个数组的长度，你可以使用这个表达式： 1array.length 但是要获取数组的元素0，你必须使用这样的表达式： 1array[0] 索引 如上所述，“索引”表示法实际上只是属性引用，尽管是一种计算形式的属性引用，而不是常数形式。例如，OGNL在内部处理 array.length表达式与这个表达式完全相同： 1array[&quot;length&quot;] 这个表达式会有相同的结果（尽管内部形式不同）： 1array[&quot;len&quot; + &quot;gth&quot;] 2.1.3 getstatic - 查看类的静态属性2.1.4 heapdump - dump java heap, 类似 jmap 命令的 heap dump 功能2.1.5 jvm - 查看当前 JVM 的信息2.1.6 logger - 查看和修改 logger2.1.7 mbean - 查看 Mbean 的信息2.1.8 memory - 查看 JVM 的内存信息2.1.9 perfcounter - 查看当前 JVM 的 Perf Counter 信息2.1.10 sysenv - 查看 JVM 的环境变量2.1.11 sysprop - 查看和修改 JVM 的系统属性2.1.12 thread - 查看当前 JVM 的线程堆栈信息2.1.13 vmoption - 查看和修改 JVM 里诊断相关的 option2.1.14 vmtool - 从 jvm 里查询对象","categories":[{"name":"Java","slug":"Java","permalink":"https://itdh.github.io/categories/Java/"},{"name":"调试工具","slug":"Java/调试工具","permalink":"https://itdh.github.io/categories/Java/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Arthas","slug":"Arthas","permalink":"https://itdh.github.io/tags/Arthas/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"https://itdh.github.io/categories/Java/"},{"name":"框架","slug":"Java/框架","permalink":"https://itdh.github.io/categories/Java/%E6%A1%86%E6%9E%B6/"},{"name":"Spring Cloud","slug":"Java/框架/Spring-Cloud","permalink":"https://itdh.github.io/categories/Java/%E6%A1%86%E6%9E%B6/Spring-Cloud/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://itdh.github.io/categories/PostgreSQL/"},{"name":"docker","slug":"docker","permalink":"https://itdh.github.io/categories/docker/"},{"name":"Spring","slug":"Java/框架/Spring","permalink":"https://itdh.github.io/categories/Java/%E6%A1%86%E6%9E%B6/Spring/"},{"name":"Spring-5.3.10","slug":"Java/框架/Spring/Spring-5-3-10","permalink":"https://itdh.github.io/categories/Java/%E6%A1%86%E6%9E%B6/Spring/Spring-5-3-10/"},{"name":"调试工具","slug":"Java/调试工具","permalink":"https://itdh.github.io/categories/Java/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://itdh.github.io/tags/PostgreSQL/"},{"name":"docker","slug":"docker","permalink":"https://itdh.github.io/tags/docker/"},{"name":"docker-compose","slug":"docker-compose","permalink":"https://itdh.github.io/tags/docker-compose/"},{"name":"Java","slug":"Java","permalink":"https://itdh.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://itdh.github.io/tags/Spring/"},{"name":"Arthas","slug":"Arthas","permalink":"https://itdh.github.io/tags/Arthas/"}]}